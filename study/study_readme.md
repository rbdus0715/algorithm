[문제 링크](https://www.algospot.com/wiki/read/JMBook_%EB%AC%B8%EC%A0%9C%EB%93%A4_%EB%A7%81%ED%81%AC)

- 도움을 많이 받은 문제 : *
- 어려워서 미룬 문제 : #
  
- [UVa Online Judge](https://onlinejudge.org/)

# Q001-007 : brute force, 재귀함수 (5/19~5/21)

# Q008-011 : divide conquer (5/22~5/25)
- 재귀함수와 가장 큰 차이 : 재귀함수는 큰 문제에서 작은 것을 하나 떼어 풀고, 떼어 풀고를 반복하는 반면 분할정복은 큰 문제를 여러 개의 동일한 소문제로 나누는 개념이다
- 분할정복 코드를 짤 때 재귀함수와 마찬가지로 (1) 기저문제, (2) 재귀적 정의 이 두 가지를 가장 먼저 생각하기
# Q012-025 : dynamic programing (5/26~6/4)
- 동적 계획법 팁
  - 모든 답을 만들어 보고 그중 최적해 점수를 반환하는 완탐 알고리즘 설계
  - 입력이 배열이거나 문자열이면 가능하다면 적절한 변환으로 메모이제이션
  - 부분 문제의 개수가 너무 많을 때, 최적 부분 조건이 성립하지 않을 때 :
    - 답이 항상 어떤 구조를 가질 것이라고 예측하고 그것을 강제하는 것
    - 정렬 등의 방법을 이용하거나 해서 주어진 데이터/문제의 특성, 성질을 잘 파악하여 일반화하기
  - dp를 두 번 이상 쓸 경우도 있으니 대비하기! (최대합 경로에서 만들었던 dp 배열을 경로 개수 문제 dp에서 재활용)

# Q026-040 : dynamic programing technique (6/5~6/15)
- 동적 계획법을 뿌시자!
  - 최적해를 직접 계산하는 문제를 만난다면 >> 원래 바탕이 되는 문제를 풀어 dp를 마련하는데, 여기서 본 문제에 도움이 되는 정보를 배열에 저장해놓는다
    - ex) [LIS 실제로 출력하기](https://github.com/rbdus0715/algorithm/blob/main/study/026_LISfind.cpp) | [실제 배낭문제 답 구하기](https://github.com/rbdus0715/algorithm/blob/main/study/027_knapsackFind.cpp)
  - k 번째 최적해를 찾는 문제 >> 완탐에서 시작해서 메모이제이션적용, skip개를 건너뛰고 첫 번째 답을 반환하는 재귀호출함수로 풀이 >> 건너뛰기 위해서는 개수를 미리 세어놔야함
    - ex) [k번째 모스부호 효율적으로 찾기](https://github.com/rbdus0715/algorithm/blob/main/study/029_morseKth.cpp) | [k-th LIS 구하기](https://github.com/rbdus0715/algorithm/blob/main/study/030_kthLIS.cpp) | [드래곤 커브 #](https://github.com/rbdus0715/algorithm/blob/main/study/031_dragonCurve%23.cpp)
  - 정수 이외의 입력에 대한 메모이제이션
    - 연관 배열 사용? map<벡터, 인트> cache : 단점은 접근 시간이나 컨테이너끼리 비교도 오래걸림
    - 일대일 대응 함수 적용하기 : 입력을 적절하게 정수로 변환
    - 입력이 순열인 경우 : 앞 자리가 4이면 그 순열 앞에 3*9!개의 입력이 옴
    - 입력 범위가 좁을 경우 : 배열 [4, 0, 1, 7, 1] 은 자연수 40171로
  - 다음 탐색으로 넘겨줘야 하는 데이터가 너무 많을 때 
    - ex) [짐바브웨문제](https://github.com/rbdus0715/algorithm/blob/main/study/032.zimbabwe%23.cpp)
    - 굳이 모든 정보들을 다 가지고 기저사례까지 가야할까? >> 그럴 필요 없이 최소한의 정보만 가지고 가면 된다
      - 최종 결과가 m으로 나누어 떨어지는지 확인 >> 나머지 연산의 분배법칙을 이용해 각 탐색마다 나머지 연산 결과만을 넘겨준다
      - 최종 결과의 크기를 비교해야 할 때 >> 높은 자리수끼리만 비교하면 됨
  - 조합 게임 : 두 사람의 참가자가 하는 게임 (체스, 오목 등)
    - winner(state, player) = 게임의 현재 상태, player가 수를 둘 차례일 때 어느쪽이 최종적으로 이기는가?
    - 혹은 더 적은 정보를 주어, winner(state) = 현재 상태에서 이번의 수를둘 차례인 참가자가 이길까?
    - ex) [틱택토](https://github.com/rbdus0715/algorithm/blob/main/study/035_tictactoe*.cpp) | [숫자게임](https://github.com/rbdus0715/algorithm/blob/main/study/036_numberGame*.cpp) | [블록게임](https://github.com/rbdus0715/algorithm/blob/main/study/037_blockGame%23.cpp)
  - 반복적 동적 계획법
    - 부분 문제 간의 의존성을 파악하기 쉬울 경우 사용 : 아래에서부터 완성시킨다
    - 슬라이딩 윈도를 통한 공간복잡도 줄이기 : 그때 그때 필요한 메모리만 사용한다
    - 행렬의 거듭제곱 이용 (피보나치 수열)
    - 반복적 동적계획법 vs 재귀적 동적계획법
      - 재귀 : 직관적/부분 문제 간 의존 관계나 계산 순서 고민 필요 없음/전체 부분 문제중 일부의 답만 필요할 경우 더 빠르게 동작 but 슬라이딩 윈도 x 스택 오버플로 조심
      - 반복 : 짧은 구현/재귀 호출의 부하가 없어 빠르게 동작/슬라이딩 윈도 but 비직관적 구현, 부분 문제간의 의존관계를 고려해 계산순서 고민해야함
  - ex) [삼각형 위의 최대 경로]() | [회전초밥]() | [지니어스]()
# Q041-045 : 탐욕법 (6/16~6/17)
  - 전체를 보지 않고, 당장의 좋은 선택을 함 -> 대부분 최적해를 찾지 못함
    1. 최적해를 구할 수 있으면 dp보다 엄청나게 빠름
    2. 다른 방법으로 최적해를 찾기 너무 어려우면 근사해를 구하는 용으로 사용
  - 한 문제를 탐욕법으로 해결하는 방법이 여러가지임 -> 그 중에 최적해로 가는 길을 찾기가 쉽지 않음 -> 공부 할 때 알고리즘의 정당성을 증명하는 과정 꼭 하기
    - 탐욕적 선택 속성 : 탐욕적으로만 선택해도 최적해를 구할 수 있는 속성
    - 최적 부분 구조 : 항상 최적의 선택만을 해서 전체 문제의 최적해를 얻을 수 있음을 보임
  - 탐욕적으로 풀 수 있는 문제는 dp로도 풀 수 있음
# Q046-048 : 조합 탐색 - 휴리스틱 (-)
  #### 휴리스틱, 결정 문제로 바꾸기는 지금 필요하지는 않아보임
  #### 정답인 풀이에 접근하지 못하겠을 때, 조금만 더 최적화를 하고싶을 때 (외판원 문제로 예시)
  - 최적해보다 나빠지면 그만두기 : 전역변수 best(지금까지의 최적 해)를  놓고, 각각의 함수에서 결과가 best보다 커지면 더 이상 나아가지 않는 방법으로 가지치기를 할 수 있다
    - if(best <= currentLength) return;
  - 간단한 휴리스틱을 이용한 가지치기 (simple ver.):
    - if(best <= currentLength + heuristic(visited)) return;
    - 여기서 휴리스틱 함수는 방문하지 않은 정점중에서 출발하는 가장 짧은 거리들의 합이다 이렇게 하면 남은 거리에 대한 최적해보다는 무조건 작아서 최적해를 지나치지 않는 선에서 효율적인 코드를 작성할 수 있다 *이해 안되면 11.2코드 확인*
  - 가까운 도시부터 방문하기
    - 각 도시마다 다른 도시들로의 경로들을 정렬해놓아 가까운 곳부터 방문하면 조금 더 최적해를 빨리 찾을 수 있다
  - 지나온 경로를 이용한 가지치기
    - 탐색의 각 단계에서 현재까지 만든 부분해에 간단한 조작을 가해 보고, 결과적으로 답이 더 좋아진다면 탐색을 중단하는 식으로 구현
    - 이때 주의할 점은 항상 현재 도시 이전의 두 도시만을 뒤집어 본다는 것 (모든 도시 쌍을 뒤집어보는게 아님)
    - 이것을 일반화하여 (p,a,b,..,g,q) 를 (p,g,f,...,a,q) 로 뒤집는 풀이할 수 있고 더 빨라짐
  - MST 휴리스틱을 이용한 가지치기 >> *작은 입력에서는 dp보다 더 빠른 속도 가능*
    - 간단한 휴리스틱에서는 문제를 너무 과소평가하는 경향이 있음 -> 방문하지 않은 정점으로 만들어 질 수 있는 최소임계치 휴리스틱 함수에서는 적어도 모든 정점이 연결되어있긴 해야함
    - 그래서 simple ver.과 다르게 최소 스패닝 트리(MST)를 구하여 그것을 최소 임계치로 사용한다
  - 마지막 단계 메모이제이션하기
    - 같은 상태를 두 번 이상 마주하는 비효율을 메모이제이션으로 제거함
    - 남은 도시의 수가 n개일 때만 메모이제이션을 하여 5!번의 연산을 한번으로 줄일 수 있다
    - 이 방법은 가지치기 풀이에서 사용이 불가능 하므로 가지치기를 사용하지 않는 동적 계획법 함수를 별도로 만들어 마지막 n개 남았을 때 이 함수를 사용하도록 구현한다
# Q049-052 : 최적화 문제 결정 문제로 바꿔 풀기 (-)
  #### skip
# Q053- : 수치 해석 (6/26~)
  - 이분법 [설명](https://blog.naver.com/rbdus0715/223116394161)
    - loop를 실수계산 문제이면 for(100)을 하고, 정수라면 while로 특정 조건까지 모두 계산하게 하기
  - 삼분검색 [설명](https://blog.naver.com/rbdus0715/223116394161)
    - 미분할 수 없는 함수에도 사용 가능, 국소 탐색에 비해 훨씬 빠름, 수렴 판정이 용이
# 정수론

# 계산 기하
- [기하 계산도구](https://github.com/rbdus0715/algorithm/blob/main/study/reusable_cal_geometric.cpp)
